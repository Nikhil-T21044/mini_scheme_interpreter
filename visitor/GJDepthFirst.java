//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst implements GJVisitor<Returnable,Environment> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public Returnable visit(NodeList n, Environment argu) {
      Returnable _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public Returnable visit(NodeListOptional n, Environment argu) {
      if ( n.present() ) {
         Returnable _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public Returnable visit(NodeOptional n, Environment argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public Returnable visit(NodeSequence n, Environment argu) {
      Returnable _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public Returnable visit(NodeToken n, Environment argu) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> ( Line() )*
    * f1 -> <EOF>
    */
   public Returnable visit(Goal n, Environment argu) {
      Returnable _ret=null;
      for(Node node : n.f0.nodes) {
    	  Returnable result = node.accept(this, argu);
    	  System.out.format(result.type().toString());
    	  System.out.format(result.print());
      }
//      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Expression()
    */
   public Returnable visit(Line n, Environment argu) {
      Returnable _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | BeginExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | MultiplyExpression()
    *       | DivideExpression()
    *       | GTExpression()
    *       | LTExpression()
    *       | EQExpression()
    *       | IfExpression()
    *       | DefineExpression()
    *       | Assignment()
    *       | ProcedureExp()
    *       | Application()
    */
   public Returnable visit(Expression n, Environment argu) {
      Returnable _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public Returnable visit(IntegerLiteral n, Environment argu) {
      IntegerReturnable _ret= new IntegerReturnable(Integer.parseInt(n.f0.tokenImage));
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "#t"
    */
   public Returnable visit(TrueLiteral n, Environment argu) {
      Returnable _ret=new BooleanReturnable(true);
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "#f"
    */
   public Returnable visit(FalseLiteral n, Environment argu) {
      Returnable _ret= new BooleanReturnable(false);
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> "begin"
    * f2 -> ( Expression() )*
    * f3 -> ")"
    */
   public Returnable visit(BeginExpression n, Environment argu) {
      Returnable _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      for(Node node: n.f2.nodes) {
    	  _ret = node.accept(this, argu);   // returning last evaluated
      }
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> "+"
    * f2 -> Expression()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public Returnable visit(PlusExpression n, Environment argu) {
      Returnable _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      Returnable result1 = n.f2.accept(this, argu);
      if(result1.type() == ReturnableType.ERR) {
    	  return result1;
      }
      Returnable result2 = n.f3.accept(this, argu);
      if(result2.type() == ReturnableType.ERR) {
    	  return result2;
      }
      n.f4.accept(this, argu);
      
      if(istypeIntegrerCompatible(result1, result2)){
		   if( ((IntegerReturnable)result1).value == ((IntegerReturnable)result2).value) {
			    int result = ((IntegerReturnable)result1).value + ((IntegerReturnable)result2).value;
			    _ret = new IntegerReturnable(result);
		   }
	   }else {
		   //TODO send Err
	   }
      
//      int result = ((IntegerReturnable)result1).value + ((IntegerReturnable)result2).value;
//      return new IntegerReturnable(result);
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> "-"
    * f2 -> Expression()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public Returnable visit(MinusExpression n, Environment argu) {
      Returnable _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      Returnable result1 = n.f2.accept(this, argu);
      if(result1.type() == ReturnableType.ERR) {
    	  return result1;
      }
      Returnable result2 = n.f3.accept(this, argu);
      if(result2.type() == ReturnableType.ERR) {
    	  return result2;
      }
      n.f4.accept(this, argu);
      if(istypeIntegrerCompatible(result1, result2)){
		   if( ((IntegerReturnable)result1).value == ((IntegerReturnable)result2).value) {
			    int result = ((IntegerReturnable)result1).value - ((IntegerReturnable)result2).value;
			    _ret = new IntegerReturnable(result);
		   }
	   }else {
		   //TODO send Err
	   }
//      int result = ((IntegerReturnable)result1).value - ((IntegerReturnable)result2).value;
//      return new IntegerReturnable(result);
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> "*"
    * f2 -> Expression()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public Returnable visit(MultiplyExpression n, Environment argu) {
      Returnable _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      Returnable result1 = n.f2.accept(this, argu);
      if(result1.type() == ReturnableType.ERR) {
    	  return result1;
      }
      Returnable result2 = n.f3.accept(this, argu);
      if(result2.type() == ReturnableType.ERR) {
    	  return result2;
      }
      n.f4.accept(this, argu);
      if(istypeIntegrerCompatible(result1, result2)){
		   if( ((IntegerReturnable)result1).value == ((IntegerReturnable)result2).value) {
			    int result = ((IntegerReturnable)result1).value * ((IntegerReturnable)result2).value;
			    _ret = new IntegerReturnable(result);
		   }
	   }else {
		   //TODO send Err
	   }
      
//      int result = ((IntegerReturnable)result1).value * ((IntegerReturnable)result2).value;
//      return new IntegerReturnable(result);
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> "/"
    * f2 -> Expression()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public Returnable visit(DivideExpression n, Environment argu) {
      Returnable _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      Returnable result1 = n.f2.accept(this, argu);
      if(result1.type() == ReturnableType.ERR) {
    	  return result1;
      }
      Returnable result2 = n.f3.accept(this, argu);
      if(result2.type() == ReturnableType.ERR) {
    	  return result2;
      }
      n.f4.accept(this, argu);
      if(istypeIntegrerCompatible(result1, result2)){
		   if( ((IntegerReturnable)result1).value == ((IntegerReturnable)result2).value) {
			    int result = ((IntegerReturnable)result1).value / ((IntegerReturnable)result2).value;
			    _ret = new IntegerReturnable(result);
		   }
	   }else {
		   //TODO send Err
	   }
//      int result = ((IntegerReturnable)result1).value / ((IntegerReturnable)result2).value;
//      return new IntegerReturnable(result);
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> ">"
    * f2 -> Expression()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public Returnable visit(GTExpression n, Environment argu) {
	   BooleanReturnable _ret=new BooleanReturnable(false);
	   n.f0.accept(this, argu);
	   n.f1.accept(this, argu);
	   Returnable result1 = n.f2.accept(this, argu);
	   if(result1.type() == ReturnableType.ERR) {
		   return result1;
	   }
	   Returnable result2 = n.f3.accept(this, argu);
	   if(result2.type() == ReturnableType.ERR) {
		   return result2;	
	   }
	   n.f4.accept(this, argu);
	   if(istypeIntegrerCompatible(result1, result2)){
		   if( ((IntegerReturnable)result1).value > ((IntegerReturnable)result2).value)   _ret.value = true;
	   }else {
		   //TODO send Err
	   }
//	   if(result1.type() != result2.type()) {
//	    // TODO check this
//	   }else if( ((IntegerReturnable)result1).value > ((IntegerReturnable)result2).value) {
//	   	  _ret.value = true;
//	   }
      return _ret;
   }
   
   public boolean isIntegerType(Returnable val) {
	   if(val.type() == ReturnableType.INT )
		   return true;
	   return false;
   }
   
   public boolean istypeCompatible(Returnable val1, Returnable val2) {
	   if(val1.type() == val2.type()) {
		   return true;	
	   }
	   return false;
   }
   
   public boolean istypeIntegrerCompatible(Returnable val1, Returnable val2) {
	   if(istypeCompatible(val1, val2) && isIntegerType(val1)){
		   return true;	
	   }
	   return false;
   }

   /**
    * f0 -> "("
    * f1 -> "<"
    * f2 -> Expression()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public Returnable visit(LTExpression n, Environment argu) {
	  BooleanReturnable _ret=new BooleanReturnable(false);
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      Returnable result1 = n.f2.accept(this, argu);
      if(result1.type() == ReturnableType.ERR) {
    	  return result1;	// stop processing with err TODO check expression for possible err also
      }
      Returnable result2 = n.f3.accept(this, argu);
      if(result2.type() == ReturnableType.ERR) {
    	  return result2;	// stop processing with err TODO check expression for possible err also
      }
      n.f4.accept(this, argu);
      
      if(istypeIntegrerCompatible(result1, result2)){
		   if( ((IntegerReturnable)result1).value < ((IntegerReturnable)result2).value)   _ret.value = true;
	   }else {
		   //TODO send Err
	   }
      
//      if(result1.type() != result2.type()) {
//    	  // TODO check this
//      }else if( ((IntegerReturnable)result1).value < ((IntegerReturnable)result2).value) {
//    	  _ret.value = true;
//      }
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public Returnable visit(EQExpression n, Environment argu) {
	  BooleanReturnable _ret= new BooleanReturnable(false);
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      Returnable result1 = n.f2.accept(this, argu);
      if(result1.type() == ReturnableType.ERR) {
    	  return result1;	// stop processing with err TODO check expression for possible err also
      }
      Returnable result2 = n.f3.accept(this, argu);
      if(result2.type() == ReturnableType.ERR) {
    	  return result2;	// stop processing with err TODO check expression for possible err also
      }
      n.f4.accept(this, argu);
      
      if(istypeIntegrerCompatible(result1, result2)){
		   if( ((IntegerReturnable)result1).value == ((IntegerReturnable)result2).value)   _ret.value = true;
	   }else {
		   //TODO send Err
	   }
      
//      if(result1.type() != result2.type()) {
//    	  // TODO check this
//      }
//      else if( ((IntegerReturnable)result1).value == ((IntegerReturnable)result2).value) {
//    	  _ret.value = true;
//      }
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> "if"
    * f2 -> Expression()
    * f3 -> Expression()
    * f4 -> Expression()
    * f5 -> ")"
    */
   public Returnable visit(IfExpression n, Environment argu) {
      Returnable _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      Returnable result = n.f2.accept(this, argu);
      if(result.type() == ReturnableType.ERR) {
    	  return result;	// stop processing with err TODO check expression for possible err also
      }
      if(result.type() != ReturnableType.BOOLEAN)
    	  return new ErrReturnable("Expected boolean value but given "+ result.print() ); //TODO check the err string
      
      if( ((BooleanReturnable) result).value ) {	// evaluting if else
    	_ret = n.f3.accept(this, argu);
      }else {
    	_ret = n.f4.accept(this, argu); 
      }
      n.f5.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> "define"
    * f2 -> Identifier()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public Returnable visit(DefineExpression n, Environment argu) {
      Returnable _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      _ret = n.f3.accept(this, argu);
      if(_ret.type() == ReturnableType.ERR) {
    	  return _ret;	// stop processing with err TODO check expression for possible err also
      }
      if(_ret.type() == ReturnableType.LAMBDA ) {
    	  ((ProcedureReturnable)_ret).setName( n.f2.f0.tokenImage);
      }
      n.f4.accept(this, argu);
      argu.add(n.f2.f0.tokenImage, _ret);// adding variable to symbol table
      return new NullReturnable() ; //  a/c to assignment
//      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public Returnable visit(Identifier n, Environment argu) {
      Returnable _ret = argu.get(n.f0.tokenImage);
      n.f0.accept(this, argu);
      if(_ret == null) {
    	  return new ErrReturnable("Symbol '" + n.f0.tokenImage +"' not found in the environment.");
      }
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> "set!"
    * f2 -> Identifier()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public Returnable visit(Assignment n, Environment argu) {
      Returnable _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      Returnable id_info = n.f2.accept(this, argu);
      if(id_info.type() == ReturnableType.ERR) {
    	  return id_info;	// stop processing with err TODO check expression for possible err also
      }
      _ret = n.f3.accept(this, argu);
      if(_ret.type() == ReturnableType.ERR )
    	  return _ret;
      
      n.f4.accept(this, argu);
      argu.update(n.f2.f0.tokenImage, _ret);//TODO check for undefined
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> "lambda"
    * f2 -> "("
    * f3 -> ( Identifier() )*
    * f4 -> ")"
    * f5 -> Expression()
    * f6 -> ")"
    */
   public Returnable visit(ProcedureExp n, Environment argu) {
      Returnable _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      ProcedureReturnable procedureDefinition = new ProcedureReturnable(argu);
      procedureDefinition.arguments = new String[n.f3.nodes.size()];
      for(int i = 0 ; i < n.f3.nodes.size() ; i++) {
    	  Node node = n.f3.nodes.get(i);
    	  procedureDefinition.addArgument( ((Identifier)node).f0.tokenImage, i);
//    	  Returnable result = node.accept(this, argu);
//    	  System.out.format(result.print());
      }
//      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      procedureDefinition.body = n.f5;
//      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      _ret = procedureDefinition; // TODO check this , only returning node
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ( Expression() )*
    * f3 -> ")"
    */
   public Returnable visit(Application n, Environment argu) {
      Returnable _ret=null;
      n.f0.accept(this, argu);
      Returnable result = n.f1.accept(this, argu);
      if(result.type() != ReturnableType.LAMBDA ) {
//    	  if( n.f1.f0.which == 3)
//    		  return new ErrReturnable("Symbol/lambda " + ((Identifier)n.f1.f0.choice).f0.tokenImage +" not found in the environment.");
    	  if(result.type() == ReturnableType.ERR) return result;
    	  return new ErrReturnable("expected function, given: "+ result.print() ); // TODO change this msg
      }
      
      int arg_len = n.f2.nodes.size();
      
      ProcedureReturnable procedure_definition =  (ProcedureReturnable)result;
      
      if(arg_len < procedure_definition.arguments.length) {
    	  return new ErrReturnable("Number of supplied arguments to procedure '"+ procedure_definition.name +"' is less than expected.");//TODO add procedure name
      }else if(arg_len > procedure_definition.arguments.length) {
    	  return new ErrReturnable("Number of supplied arguments to procedure '"+ procedure_definition.name +"' is greater than expected.");//TODO add procedure name
      }
      
      // lexical scoping  
      Environment scope = new Environment(procedure_definition.getScope());
      //Tip: change scope to current environment to make it dynamic scoping
      
      for (int i = 0; i < procedure_definition.arguments.length; i++) { // binding formal to actual
    	  Node node = n.f2.nodes.get(i);
    	  scope.add(procedure_definition.arguments[i], node.accept(this, argu));
      }
//      n.f2.accept(this, argu);
      
      _ret = procedure_definition.body.accept(this,scope); // calling function
      n.f3.accept(this, argu);
      return _ret;
   }

}
